# SSBMax - World-Class Android App Cursor Rules
# Specialized rules for building an exceptional SSB (Services Selection Board) preparation app
# Last Updated: October 30, 2025

## üéØ PROJECT OVERVIEW
You are building SSBMax, a comprehensive Android app for SSB preparation that helps candidates:
- Access structured study materials for Psychology, GTO, Interview, and Conference stages
- Practice authentic SSB tests (TAT, WAT, SRT, SDT, GTO tasks)
- Track progress and performance analytics
- Get personalized tips and guidance
- Simulate real SSB testing conditions

## üèóÔ∏è ARCHITECTURE & DESIGN PATTERNS

### Core Architecture
- **Pattern**: MVVM (Model-View-ViewModel) with Repository pattern
- **UI Framework**: Jetpack Compose (100% Compose, no XML layouts)
- **Navigation**: Jetpack Navigation Compose with type-safe navigation
- **State Management**: StateFlow & Compose State with proper hoisting
- **Dependency Injection**: Hilt/Dagger for clean architecture
- **Async Operations**: Kotlin Coroutines with structured concurrency
- **Local Storage**: Room Database + DataStore Preferences
- **Backend**: Firebase (Auth, Firestore, Storage, Messaging, Analytics)

### Tech Stack (Current Versions - Oct 2025)
```kotlin
// Core
Kotlin: 2.1.0
AGP: 8.13.0
Compose BOM: 2024.12.01
compileSdk: 35
targetSdk: 35
minSdk: 26
JVM Target: 17

// Key Libraries
Hilt: 2.52
Room: 2.6.1
Coroutines: 1.9.0
Coil: 2.5.0
Firebase BOM: 33.7.0
Navigation Compose: 2.8.5
```

### Multi-Module Architecture
```
SSBMax/
‚îú‚îÄ‚îÄ app/                          # Main application module
‚îÇ   ‚îú‚îÄ‚îÄ ui/                       # Compose UI screens & components
‚îÇ   ‚îú‚îÄ‚îÄ navigation/               # Navigation graphs
‚îÇ   ‚îú‚îÄ‚îÄ notifications/            # FCM messaging service
‚îÇ   ‚îî‚îÄ‚îÄ di/                       # App-level DI modules
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ designsystem/            # Reusable Compose components, theme
‚îÇ   ‚îú‚îÄ‚îÄ domain/                  # Business logic, use cases, models
‚îÇ   ‚îî‚îÄ‚îÄ data/                    # Repositories, data sources, Room DB
‚îî‚îÄ‚îÄ gradle/
    ‚îî‚îÄ‚îÄ libs.versions.toml       # Centralized version catalog
```

### Package Structure (App Module)
```
com.ssbmax/
‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îú‚îÄ‚îÄ auth/                    # Login, role selection
‚îÇ   ‚îú‚îÄ‚îÄ home/                    # Student & instructor dashboards
‚îÇ   ‚îú‚îÄ‚îÄ tests/                   # Test modules (TAT, WAT, SRT, OIR, PPDT)
‚îÇ   ‚îú‚îÄ‚îÄ study/                   # Study materials
‚îÇ   ‚îú‚îÄ‚îÄ profile/                 # User profiles
‚îÇ   ‚îú‚îÄ‚îÄ notifications/           # Notification center
‚îÇ   ‚îú‚îÄ‚îÄ premium/                 # Subscription & upgrades
‚îÇ   ‚îú‚îÄ‚îÄ settings/                # App settings & migrations
‚îÇ   ‚îú‚îÄ‚îÄ components/              # Shared UI components
‚îÇ   ‚îî‚îÄ‚îÄ theme/                   # Material 3 theming
‚îú‚îÄ‚îÄ navigation/                  # Navigation graphs
‚îú‚îÄ‚îÄ notifications/               # FCM service
‚îî‚îÄ‚îÄ di/                         # Dependency injection
```

## üì± UI/UX EXCELLENCE WITH JETPACK COMPOSE

### Material Design 3 Implementation
```kotlin
// Use Material 3 with dynamic theming
@Composable
fun SSBMaxTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true, // Material You support
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            if (darkTheme) dynamicDarkColorScheme(context)
            else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    
    MaterialTheme(
        colorScheme = colorScheme,
        typography = SSBMaxTypography,
        content = content
    )
}
```

### Compose Best Practices
```kotlin
// 1. Proper state hoisting
@Composable
fun StatelessComponent(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    // Component doesn't own state
}

// 2. Use remember & rememberSaveable appropriately
@Composable
fun StatefulComponent() {
    var expanded by remember { mutableStateOf(false) } // Lost on config change
    var userName by rememberSaveable { mutableStateOf("") } // Survives config change
}

// 3. Collect StateFlow/Flow with lifecycle awareness
@Composable
fun ObserveViewModel(viewModel: MyViewModel) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    when (uiState) {
        is UiState.Loading -> LoadingIndicator()
        is UiState.Success -> ContentScreen(data = uiState.data)
        is UiState.Error -> ErrorScreen(message = uiState.message)
    }
}

// 4. Side effects with proper coroutine scopes
@Composable
fun ComponentWithSideEffect() {
    LaunchedEffect(Unit) { /* Runs once when composable enters composition */ }
    DisposableEffect(Unit) { 
        onDispose { /* Cleanup */ }
    }
}

// 5. Avoid recomposition with derivedStateOf
@Composable
fun ExpensiveComputation(items: List<Item>) {
    val filteredItems by remember(items) {
        derivedStateOf { items.filter { it.isActive } }
    }
}
```

### SSB-Specific UI Components (Compose)
```kotlin
// Custom timer component for SSB tests
@Composable
fun SSBTestTimer(
    remainingMillis: Long,
    totalMillis: Long,
    onTimeExpired: () -> Unit,
    modifier: Modifier = Modifier
) {
    val progress = (remainingMillis.toFloat() / totalMillis).coerceIn(0f, 1f)
    
    Column(modifier = modifier) {
        LinearProgressIndicator(
            progress = { progress },
            modifier = Modifier.fillMaxWidth(),
            color = when {
                progress > 0.5f -> MaterialTheme.colorScheme.primary
                progress > 0.2f -> MaterialTheme.colorScheme.tertiary
                else -> MaterialTheme.colorScheme.error
            }
        )
        Text(
            text = formatTime(remainingMillis),
            style = MaterialTheme.typography.titleLarge
        )
    }
}

// Markdown rendering for study materials
@Composable
fun MarkdownText(
    content: String,
    textColor: Color = MaterialTheme.colorScheme.onSurfaceVariant,
    modifier: Modifier = Modifier
) {
    // Custom AnnotatedString-based markdown parser
    // Supports: headings, bullets, numbered lists, **bold**
    // See: app/src/main/kotlin/com/ssbmax/ui/components/MarkdownText.kt
}

// Premium content with lock overlay
@Composable
fun PremiumLockCard(
    isPremiumUser: Boolean,
    onUpgradeClick: () -> Unit,
    content: @Composable () -> Unit
) {
    Box {
        content()
        if (!isPremiumUser) {
            // Show premium lock overlay
        }
    }
}
```

### Navigation & Deep Linking (Compose)
```kotlin
// Type-safe navigation with sealed classes
sealed class SSBMaxDestination(val route: String) {
    object Dashboard : SSBMaxDestination("dashboard")
    data class TestDetail(val testId: String) : SSBMaxDestination("test/{testId}") {
        fun createRoute(testId: String) = "test/$testId"
    }
}

// Navigation setup
@Composable
fun SSBMaxNavHost(
    navController: NavHostController,
    startDestination: String
) {
    NavHost(navController = navController, startDestination = startDestination) {
        composable(SSBMaxDestination.Dashboard.route) {
            DashboardScreen(onNavigateToTest = { testId ->
                navController.navigate(SSBMaxDestination.TestDetail.createRoute(testId))
            })
        }
        composable(
            route = SSBMaxDestination.TestDetail.route,
            arguments = listOf(navArgument("testId") { type = NavType.StringType })
        ) { backStackEntry ->
            TestDetailScreen(testId = backStackEntry.arguments?.getString("testId"))
        }
    }
}
```

## üß† SSB TEST IMPLEMENTATION

### Psychology Tests Module (Compose)
```kotlin
// TAT (Thematic Apperception Test)
@Composable
fun TATTestScreen(
    viewModel: TATViewModel = hiltViewModel(),
    onComplete: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    Scaffold { padding ->
        Column(modifier = Modifier.padding(padding)) {
            // Image with zoom capability (Coil + transformable state)
            AsyncImage(
                model = uiState.currentImage,
                contentDescription = "TAT Image",
                modifier = Modifier.graphicsLayer {
                    scaleX = scale
                    scaleY = scale
                }
            )
            
            // Timer
            SSBTestTimer(
                remainingMillis = uiState.remainingTime,
                totalMillis = 240_000L, // 4 minutes per image
                onTimeExpired = { viewModel.onTimeExpired() }
            )
            
            // Story input
            OutlinedTextField(
                value = uiState.storyText,
                onValueChange = viewModel::onStoryChanged,
                maxLines = 10,
                supportingText = {
                    Text("${uiState.storyText.length} characters")
                }
            )
        }
    }
}

// WAT (Word Association Test) - 15 seconds per word
@Composable
fun WATTestScreen(
    viewModel: WATViewModel = hiltViewModel()
) {
    val currentWord by viewModel.currentWord.collectAsStateWithLifecycle()
    val timeRemaining by viewModel.timeRemaining.collectAsStateWithLifecycle()
    
    Column {
        Text(
            text = currentWord,
            style = MaterialTheme.typography.displayLarge
        )
        
        TextField(
            value = viewModel.responseText,
            onValueChange = viewModel::onResponseChanged,
            placeholder = { Text("Type your response...") },
            singleLine = true
        )
        
        LinearProgressIndicator(
            progress = { timeRemaining / 15f },
            modifier = Modifier.fillMaxWidth()
        )
    }
}
```

### Test Engine Architecture
```kotlin
// Sealed class for test types
sealed class TestType {
    data object TAT : TestType()
    data object WAT : TestType()
    data object SRT : TestType()
    data object OIR : TestType()
    data object PPDT : TestType()
}

// Test state management
sealed class TestState {
    data object NotStarted : TestState()
    data object Loading : TestState()
    data class InProgress(
        val currentQuestion: Int,
        val totalQuestions: Int,
        val remainingTime: Long
    ) : TestState()
    data class Completed(val result: TestResult) : TestState()
    data class Error(val message: String) : TestState()
}

// ViewModel pattern for tests
@HiltViewModel
class TestViewModel @Inject constructor(
    private val testRepository: TestRepository,
    private val analyticsRepository: AnalyticsRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val testId: String = savedStateHandle["testId"] ?: ""
    
    private val _uiState = MutableStateFlow<TestState>(TestState.NotStarted)
    val uiState: StateFlow<TestState> = _uiState.asStateFlow()
    
    fun startTest() {
        viewModelScope.launch {
            _uiState.value = TestState.Loading
            try {
                val test = testRepository.getTest(testId)
                _uiState.value = TestState.InProgress(
                    currentQuestion = 1,
                    totalQuestions = test.questions.size,
                    remainingTime = test.timeLimit
                )
            } catch (e: Exception) {
                _uiState.value = TestState.Error(e.message ?: "Unknown error")
            }
        }
    }
    
    fun submitTest(responses: List<TestResponse>) {
        viewModelScope.launch {
            val result = testRepository.submitTest(testId, responses)
            analyticsRepository.trackTestCompletion(testId, result.score)
            _uiState.value = TestState.Completed(result)
        }
    }
}
```

## üìä DATA LAYER & FIREBASE INTEGRATION

### Repository Pattern with Firebase
```kotlin
@Singleton
class AuthRepository @Inject constructor(
    private val firebaseAuth: FirebaseAuth,
    private val firestore: FirebaseFirestore
) {
    private val _currentUser = MutableStateFlow<User?>(null)
    val currentUser: StateFlow<User?> = _currentUser.asStateFlow()
    
    init {
        // Observe Firebase auth state changes
        viewModelScope.launch {
            firebaseAuth.authStateChanges().collect { firebaseUser ->
                if (firebaseUser != null) {
                    loadUserProfile(firebaseUser.uid)
                } else {
                    _currentUser.value = null
                }
            }
        }
    }
    
    private suspend fun loadUserProfile(userId: String) {
        try {
            val profile = firestore.collection("users")
                .document(userId)
                .collection("data")
                .document("profile")
                .get()
                .await()
                .toObject<UserProfile>()
            
            _currentUser.value = profile
        } catch (e: Exception) {
            Log.e("AuthRepository", "Failed to load profile", e)
        }
    }
}

// Firestore data structure: users/{userId}/data/profile
// Requires nested security rules for subcollections
```

### Room Database Setup
```kotlin
@Entity(tableName = "test_results")
data class TestResultEntity(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val testType: String,
    val score: Float,
    val completedAt: Long = System.currentTimeMillis(),
    val timeSpent: Long,
    val responses: String // JSON serialized
)

@Dao
interface TestResultDao {
    @Query("SELECT * FROM test_results WHERE testType = :type ORDER BY completedAt DESC")
    fun getResultsByType(type: String): Flow<List<TestResultEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertResult(result: TestResultEntity)
}

@Database(
    entities = [TestResultEntity::class, StudyProgressEntity::class],
    version = 1,
    exportSchema = true
)
abstract class SSBMaxDatabase : RoomDatabase() {
    abstract fun testResultDao(): TestResultDao
}
```

### DataStore for Preferences
```kotlin
val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")

class SettingsRepository @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    val themeMode: Flow<ThemeMode> = dataStore.data
        .map { preferences ->
            ThemeMode.valueOf(preferences[THEME_MODE_KEY] ?: ThemeMode.SYSTEM.name)
        }
    
    suspend fun setThemeMode(mode: ThemeMode) {
        dataStore.edit { preferences ->
            preferences[THEME_MODE_KEY] = mode.name
        }
    }
}
```

## ‚ö° PERFORMANCE OPTIMIZATION

### Compose Performance
```kotlin
// 1. Use keys in LazyColumn for stable items
LazyColumn {
    items(items = testList, key = { it.id }) { test ->
        TestCard(test = test)
    }
}

// 2. Avoid unnecessary recomposition with stable classes
@Immutable
data class TestData(val id: String, val title: String)

// 3. Use derivedStateOf for computed values
val filteredTests by remember(tests, searchQuery) {
    derivedStateOf {
        tests.filter { it.title.contains(searchQuery, ignoreCase = true) }
    }
}

// 4. Defer expensive operations with LaunchedEffect
LaunchedEffect(testId) {
    // Load test data asynchronously
    viewModel.loadTest(testId)
}
```

### Memory Management
```kotlin
// Image loading with Coil
AsyncImage(
    model = ImageRequest.Builder(LocalContext.current)
        .data(imageUrl)
        .crossfade(true)
        .memoryCachePolicy(CachePolicy.ENABLED)
        .diskCachePolicy(CachePolicy.ENABLED)
        .build(),
    contentDescription = null,
    contentScale = ContentScale.Crop
)

// Proper coroutine scoping in ViewModels
class MyViewModel : ViewModel() {
    init {
        viewModelScope.launch {
            // Automatically cancelled when ViewModel is cleared
        }
    }
}
```

### Background Processing
```kotlin
// Use WorkManager for sync operations
class SyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        return try {
            syncRepository.syncData()
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
}

// Schedule periodic sync
val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
    repeatInterval = 6,
    repeatIntervalTimeUnit = TimeUnit.HOURS
).setConstraints(
    Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)
        .setRequiresBatteryNotLow(true)
        .build()
).build()

WorkManager.getInstance(context).enqueueUniquePeriodicWork(
    "SyncWork",
    ExistingPeriodicWorkPolicy.KEEP,
    syncRequest
)
```

## üß™ TESTING STRATEGY

### Unit Tests with Mockk
```kotlin
@Test
fun `test calculation returns correct score`() = runTest {
    // Given
    val repository = mockk<TestRepository>()
    coEvery { repository.getTest(any()) } returns mockTest
    
    val viewModel = TestViewModel(repository)
    
    // When
    viewModel.submitTest(mockResponses)
    
    // Then
    val state = viewModel.uiState.value
    assertTrue(state is TestState.Completed)
    assertEquals(85.0f, (state as TestState.Completed).result.score)
}
```

### Compose UI Tests
```kotlin
@RunWith(AndroidJUnit4::class)
class TATTestScreenTest {
    @get:Rule
    val composeTestRule = createComposeRule()
    
    @Test
    fun testTimer_displaysCorrectly() {
        composeTestRule.setContent {
            SSBTestTimer(
                remainingMillis = 120_000L,
                totalMillis = 240_000L,
                onTimeExpired = {}
            )
        }
        
        composeTestRule.onNodeWithText("2:00").assertIsDisplayed()
    }
}
```

### Integration Tests with Hilt
```kotlin
@HiltAndroidTest
class EndToEndTestFlowTest {
    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)
    
    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<MainActivity>()
    
    @Test
    fun completeTest_savesResult_showsInHistory() {
        // Navigate to test
        composeTestRule.onNodeWithText("Start TAT").performClick()
        
        // Complete test
        composeTestRule.onNodeWithText("Submit").performClick()
        
        // Verify result appears in history
        composeTestRule.onNodeWithText("Test History").performClick()
        composeTestRule.onNodeWithText("TAT Test").assertIsDisplayed()
    }
}
```

## üîí SECURITY & PRIVACY

### Firebase Security Rules
```javascript
// Firestore rules for nested subcollections
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    
    match /users/{userId} {
      allow read, write: if isOwner(userId);
      
      // CRITICAL: Nested rules for subcollections
      match /data/{document} {
        allow read, write: if isOwner(userId);
      }
      
      match /test_results/{resultId} {
        allow read, write: if isOwner(userId);
      }
    }
  }
}
```

### Data Encryption
```kotlin
// Encrypted SharedPreferences for sensitive data
val masterKey = MasterKey.Builder(context)
    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
    .build()

val encryptedPrefs = EncryptedSharedPreferences.create(
    context,
    "secure_prefs",
    masterKey,
    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
)
```

## üåê PUSH NOTIFICATIONS (FCM)

### Firebase Cloud Messaging Service
```kotlin
@AndroidEntryPoint
class SSBMaxFirebaseMessagingService : FirebaseMessagingService() {
    
    @Inject lateinit var notificationRepository: NotificationRepository
    
    override fun onMessageReceived(remoteMessage: RemoteMessage) {
        super.onMessageReceived(remoteMessage)
        
        // Handle notification payload
        remoteMessage.notification?.let { notification ->
            showNotification(
                title = notification.title ?: "",
                body = notification.body ?: "",
                data = remoteMessage.data
            )
        }
        
        // Save to local database
        CoroutineScope(Dispatchers.IO).launch {
            notificationRepository.saveNotification(
                NotificationEntity(
                    title = remoteMessage.notification?.title ?: "",
                    body = remoteMessage.notification?.body ?: "",
                    receivedAt = System.currentTimeMillis()
                )
            )
        }
    }
    
    override fun onNewToken(token: String) {
        super.onNewToken(token)
        // Upload token to Firestore
        CoroutineScope(Dispatchers.IO).launch {
            notificationRepository.updateFCMToken(token)
        }
    }
}
```

## üìã CODING STANDARDS & BEST PRACTICES

### Kotlin Best Practices
```kotlin
// 1. Use sealed classes for state management
sealed interface UiState<out T> {
    data object Loading : UiState<Nothing>
    data class Success<T>(val data: T) : UiState<T>
    data class Error(val message: String) : UiState<Nothing>
}

// 2. Use data classes with validation
data class TestScore(
    val value: Float
) {
    init {
        require(value in 0f..100f) { "Score must be between 0 and 100" }
    }
}

// 3. Extension functions for utilities
fun Context.showToast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

// 4. Proper coroutine exception handling
viewModelScope.launch {
    try {
        val result = repository.fetchData()
        _uiState.value = UiState.Success(result)
    } catch (e: CancellationException) {
        throw e // Don't catch cancellation
    } catch (e: Exception) {
        _uiState.value = UiState.Error(e.message ?: "Unknown error")
        Log.e(TAG, "Error fetching data", e)
    }
}
```

### File Size Limit
**CRITICAL**: No file should exceed **300 lines of code**. If approaching this limit:
1. Extract utility functions to separate files
2. Split large classes into focused components
3. Create separate ViewModel/Repository classes
4. Use composition over large single classes

### Code Organization
- One class per file
- Meaningful naming (UserProfileViewModel, not UPViewModel)
- Proper KDoc for public APIs
- Group related functions with region comments
- No magic numbers - use constants

## üéØ SSB-SPECIFIC FEATURES

### Authentic Test Simulation
- **Exact Timing**: Match real SSB test durations (e.g., WAT: 15s per word, TAT: 4min per image)
- **Auto-progression**: Automatic advancement when time expires
- **Auto-save**: Save responses every 30 seconds to prevent data loss
- **Offline Support**: Allow tests to be taken offline with sync later

### Content Management
```kotlin
// Centralized markdown rendering
@Composable
fun MarkdownText(
    content: String,
    textColor: Color = MaterialTheme.colorScheme.onSurfaceVariant
) {
    // Use AnnotatedString with SpanStyle for formatting
    // Supports: #headings, **bold**, bullet lists, numbered lists
    // This is the ONLY way to render long-form content
}

// Usage in study materials
@Composable
fun StudyMaterialScreen(content: String) {
    LazyColumn {
        item {
            MarkdownText(content = content)
        }
    }
}
```

### Role-Based Access (Student vs Instructor)
```kotlin
sealed class UserRole {
    data object Student : UserRole()
    data object Instructor : UserRole()
    data object Admin : UserRole()
}

// Different navigation graphs per role
@Composable
fun SSBMaxApp(userRole: UserRole) {
    when (userRole) {
        UserRole.Student -> StudentNavGraph()
        UserRole.Instructor -> InstructorNavGraph()
        UserRole.Admin -> AdminNavGraph()
    }
}
```

### Subscription Model (SINGLE SOURCE OF TRUTH)

**Monthly Test Limits by Tier:**

| Test Type | FREE | PRO | PREMIUM |
|-----------|------|-----|---------|
| OIR | 1 | 5 | Unlimited |
| PPDT | 1 | 5 | Unlimited |
| PIQ | 1 | Unlimited | Unlimited |
| TAT | 0 | 3 | Unlimited |
| WAT | 0 | 3 | Unlimited |
| SRT | 0 | 3 | Unlimited |
| Self Description | 0 | 3 | Unlimited |
| GTO (each of 8 tests) | 0 | 3 | Unlimited |
| Interview | 0 | 1 | Unlimited |

**Key Points:**
- GTO: PRO tier gets 3 attempts for EACH of the 8 GTO sub-tests (Group Discussion, Group Planning Exercise, Progressive Group Task, Group Obstacle Race, Half Group Task, Lecturette, Individual Obstacles, Command Task)
- PIQ: FREE tier gets 1 form (required for Interview), PRO/PREMIUM get unlimited updates
- Limits reset on 1st of each month
- Server-side enforcement via Firestore (cannot be bypassed by clearing app cache)

**Implementation Location:**
- `core/data/src/main/kotlin/com/ssbmax/core/data/repository/SubscriptionManager.kt` - `getTestLimitForTier()` function
- This is the SINGLE SOURCE OF TRUTH - all other displays derive from this

### Premium/Subscription Features
```kotlin
// Premium gating with graceful UI
@Composable
fun PremiumFeature(
    isPremiumUser: Boolean,
    onUpgradeClick: () -> Unit,
    content: @Composable () -> Unit
) {
    if (isPremiumUser) {
        content()
    } else {
        PremiumLockCard(
            onUpgradeClick = onUpgradeClick,
            featureName = "Advanced Analytics"
        )
    }
}
```

## üîß DEBUGGING & TROUBLESHOOTING

### Common Issues & Solutions

#### 1. Firebase "Null State" Bug
**Symptom**: UI shows empty state even though data exists in Firestore

**Solution**: Three-state pattern
```kotlin
data class UiState<T>(
    val isLoading: Boolean = false,
    val data: T? = null,
    val error: String? = null
)

@Composable
fun DataScreen(uiState: UiState<List<Test>>) {
    when {
        uiState.isLoading -> LoadingSpinner()
        uiState.data != null -> ContentList(uiState.data)
        uiState.error != null -> ErrorMessage(uiState.error)
        else -> EmptyState()
    }
}
```

#### 2. Repository Lazy Initialization Race Condition
**Issue**: AuthRepository singleton injected lazily, so its `init` block doesn't run until first access

**Solution**: Ensure eager initialization or check `isAuthenticated()` in ViewModels
```kotlin
@Singleton
class AuthRepository @Inject constructor(...) {
    init {
        // This runs immediately when repository is created
        observeAuthState()
    }
}

// In ViewModel
init {
    viewModelScope.launch {
        if (authRepository.isAuthenticated()) {
            val user = authRepository.currentUser.first { it != null }
            loadUserData(user)
        }
    }
}
```

#### 3. Firestore Permission Denied
**Issue**: Security rules don't cover nested subcollections

**Solution**: Add nested `match` blocks in firestore.rules
```javascript
match /users/{userId} {
  allow read, write: if isOwner(userId);
  
  // Don't forget subcollection rules!
  match /data/{document} {
    allow read, write: if isOwner(userId);
  }
}
```

### Strategic Logging
```kotlin
// Add comprehensive logging at critical points
class MyRepository @Inject constructor() {
    init {
        Log.d(TAG, "Repository initialized")
    }
    
    private val _data = callbackFlow<Data> {
        Log.d(TAG, "Starting Flow collection")
        // ...
    }
    
    fun getData(): Flow<Data> {
        Log.d(TAG, "getData() called")
        return _data
    }
}

class MyViewModel @Inject constructor(
    private val repository: MyRepository
) : ViewModel() {
    init {
        Log.d(TAG, "ViewModel initialized")
        viewModelScope.launch {
            repository.getData().collect { data ->
                Log.d(TAG, "Received data: $data")
            }
        }
    }
}
```

## üöÄ DEPLOYMENT & BUILD CONFIGURATION

### Build Types
```kotlin
android {
    buildTypes {
        debug {
            isDebuggable = true
            applicationIdSuffix = ".debug"
            versionNameSuffix = "-debug"
            // Use debug Firebase project
        }
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
            signingConfig = signingConfigs.getByName("release")
        }
    }
}
```

### ProGuard Rules
```proguard
# Firebase
-keepattributes Signature
-keepattributes *Annotation*
-keep class com.google.firebase.** { *; }

# Kotlin Coroutines
-keepnames class kotlinx.coroutines.internal.MainDispatcherFactory {}
-keepnames class kotlinx.coroutines.CoroutineExceptionHandler {}

# Room
-keep class * extends androidx.room.RoomDatabase
-dontwarn androidx.room.paging.**
```

## üéì LEARNING RESOURCES

### Official Documentation
- [Jetpack Compose](https://developer.android.com/jetpack/compose)
- [Material Design 3](https://m3.material.io/)
- [Kotlin Coroutines](https://kotlinlang.org/docs/coroutines-overview.html)
- [Hilt Dependency Injection](https://dagger.dev/hilt/)
- [Firebase for Android](https://firebase.google.com/docs/android/setup)

### Best Practices
- [Android Architecture Guide](https://developer.android.com/topic/architecture)
- [Compose Performance](https://developer.android.com/jetpack/compose/performance)
- [Coroutine Best Practices](https://developer.android.com/kotlin/coroutines/coroutines-best-practices)

## üìù CHANGELOG TRACKING

When making significant changes, update the relevant documentation:
- Architecture changes ‚Üí Update `.cursorrules` and `docs/architecture/`
- Bug fixes ‚Üí Log in `docs/troubleshooting/`
- New features ‚Üí Document in `docs/implementation/`
- Migrations ‚Üí Track in `docs/migration/`

### Documentation File Policy

**CRITICAL RULE**: 
- **DO NOT** automatically create markdown (.md) files during normal development operations
- **DO NOT** create status reports, summaries, completion documents, or progress updates as .md files
- **DO** create and save .md files when the user **explicitly requests** documentation creation

**When User Explicitly Requests Documentation**:
- User says: "create documentation", "write a guide", "save as markdown", "create a PRD", "write a README", etc.
- Agent should create the requested .md file(s) in the appropriate location (typically `/docs/` directory)
- Agent should save the file(s) using the `write` tool

**Examples of Explicit Requests**:
- ‚úÖ "Create a PRD for the new feature"
- ‚úÖ "Write documentation for this module"
- ‚úÖ "Save this as a markdown file"
- ‚úÖ "Create a guide for X"
- ‚ùå "Implement feature X" (don't create docs automatically)
- ‚ùå "Fix bug Y" (don't create status reports)

## ‚úÖ CODE REVIEW CHECKLIST

Before submitting code:
- [ ] Follows MVVM architecture with proper separation of concerns
- [ ] Uses Jetpack Compose with proper state management
- [ ] Implements proper error handling with try-catch and sealed classes
- [ ] No memory leaks (proper ViewModel scoping, no static context references)
- [ ] Accessibility support (content descriptions, semantic properties)
- [ ] Performance optimized (stable keys, derivedStateOf, lazy loading)
- [ ] Security considerations (input validation, proper Firebase rules)
- [ ] Test coverage (unit tests for ViewModels, UI tests for critical flows)
- [ ] No files exceeding 300 lines
- [ ] Documentation updated (KDoc for public APIs)
- [ ] No hardcoded strings (use string resources)
- [ ] Proper logging (strategic debug logs, no sensitive data)

## üéØ DEVELOPMENT PRIORITIES

1. **Correctness**: App must work reliably without crashes
2. **User Experience**: Smooth, intuitive, Material Design 3 compliant
3. **Performance**: Fast load times, smooth animations, efficient memory usage
4. **Security**: Proper authentication, data encryption, secure communication
5. **Maintainability**: Clean architecture, readable code, comprehensive tests
6. **Authenticity**: Match real SSB test conditions and content

---

**Remember**: The goal is to create an app that genuinely helps SSB candidates succeed while providing an exceptional, world-class user experience. Focus on authenticity, accuracy, and user engagement throughout the development process.
