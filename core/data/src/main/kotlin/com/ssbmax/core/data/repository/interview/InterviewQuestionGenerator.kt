package com.ssbmax.core.data.repository.interview

import android.content.Context
import android.util.Log
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.ssbmax.core.domain.constants.InterviewConstants
import com.ssbmax.core.domain.model.interview.InterviewQuestion
import com.ssbmax.core.domain.model.interview.OLQ
import com.ssbmax.core.domain.model.interview.QuestionCacheRepository
import com.ssbmax.core.domain.model.interview.QuestionSource
import com.ssbmax.core.domain.repository.SubmissionRepository
import com.ssbmax.core.domain.service.AIService
import dagger.hilt.android.qualifiers.ApplicationContext
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Generates interview questions using hybrid caching strategy
 *
 * Strategy:
 * 1. Try to get questions from cache (fast, no API cost)
 *    - 70% PIQ-based questions (pre-generated by background worker after PIQ submission)
 *    - 25% Generic questions (from permanent curated question pool)
 *    - 5% reserved for future adaptive AI questions
 * 2. If cache empty, use AI to generate personalized questions from PIQ
 * 3. Cache the AI-generated questions for future use (30-day expiration)
 * 4. Fall back to mock questions only if AI fails (development only)
 */
@Singleton
class InterviewQuestionGenerator @Inject constructor(
    @ApplicationContext private val context: Context,
    private val questionCacheRepository: QuestionCacheRepository,
    private val aiService: AIService,
    private val submissionRepository: SubmissionRepository,
    private val piqDataMapper: PIQDataMapper
) {
    private val gson = Gson()

    companion object {
        private const val TAG = "QuestionGenerator"
    }

    /**
     * Generate questions for an interview session
     *
     * @param piqSnapshotId PIQ submission ID for personalized questions
     * @param count Total questions to generate
     * @return Result containing list of questions or error
     */
    suspend fun generateQuestions(
        piqSnapshotId: String,
        count: Int
    ): Result<List<InterviewQuestion>> {
        return try {
            // Calculate question distribution using defined ratios
            val piqCount = (count * InterviewConstants.PIQ_QUESTION_RATIO).toInt()
            val genericCount = (count * InterviewConstants.GENERIC_QUESTION_RATIO).toInt()

            // STEP 1: Try to get questions from cache
            val piqQuestions = questionCacheRepository.getPIQQuestions(
                piqSnapshotId = piqSnapshotId,
                limit = piqCount,
                excludeUsed = true
            ).getOrDefault(emptyList())

            val genericQuestions = questionCacheRepository.getGenericQuestions(
                targetOLQs = null,
                difficulty = InterviewConstants.MEDIUM_DIFFICULTY,
                limit = genericCount,
                excludeUsed = true
            ).getOrDefault(emptyList())

            // Combine and shuffle cached questions
            var allQuestions = (piqQuestions + genericQuestions).shuffled()

            // STEP 2: If cache is empty, use AI to generate personalized questions
            if (allQuestions.isEmpty()) {
                Log.i(TAG, "üìù Question cache empty. Generating $count AI-powered questions from PIQ data...")
                allQuestions = generateAIQuestions(piqSnapshotId, count)
            }

            // STEP 3: Final fallback to mock questions if AI failed
            if (allQuestions.isEmpty()) {
                Log.w(TAG, "‚ö†Ô∏è AI generation failed. Using $count mock questions for development")
                allQuestions = generateMockQuestions(count)
            }

            Result.success(allQuestions.take(count))
        } catch (e: Exception) {
            Log.e(TAG, "Failed to generate interview questions", e)
            Result.failure(e)
        }
    }

    /**
     * Generate questions using AI from PIQ data
     *
     * Uses the comprehensive PIQ context builder to provide Gemini AI
     * with all available candidate information for personalized questions.
     */
    private suspend fun generateAIQuestions(
        piqSnapshotId: String,
        count: Int
    ): List<InterviewQuestion> {
        // Get PIQ submission data
        val piqResult = submissionRepository.getSubmission(piqSnapshotId)

        if (piqResult.isFailure) {
            Log.e(TAG, "Could not fetch PIQ submission: $piqSnapshotId")
            return emptyList()
        }

        val piqSubmissionMap = piqResult.getOrNull() ?: return emptyList()

        // Build comprehensive PIQ context for AI (extracts all 60+ fields)
        val piqContext = piqDataMapper.buildComprehensivePIQContext(piqSubmissionMap)

        if (piqContext.isBlank() || piqContext.contains("Error processing PIQ")) {
            Log.e(TAG, "PIQ context building failed for ID: $piqSnapshotId")
            return emptyList()
        }

        Log.d(TAG, "üìã Built comprehensive PIQ context (${piqContext.length} chars) for question generation")

        // Generate AI questions with full PIQ context
        val aiQuestionsResult = aiService.generatePIQBasedQuestions(
            piqData = piqContext,
            targetOLQs = null, // Generate balanced set across all OLQ clusters
            count = count,
            difficulty = InterviewConstants.MEDIUM_DIFFICULTY
        )

        if (aiQuestionsResult.isFailure) {
            Log.e(TAG, "AI question generation failed for PIQ: $piqSnapshotId",
                aiQuestionsResult.exceptionOrNull())
            return emptyList()
        }

        val aiQuestions = aiQuestionsResult.getOrNull() ?: emptyList()

        if (aiQuestions.isEmpty()) {
            Log.e(TAG, "AI returned empty questions list for PIQ: $piqSnapshotId")
            return emptyList()
        }

        Log.i(TAG, "‚úÖ AI generated ${aiQuestions.size} personalized questions!")

        // Cache the AI-generated questions for future use
        questionCacheRepository.cachePIQQuestions(
            piqSnapshotId = piqSnapshotId,
            questions = aiQuestions,
            expirationDays = InterviewConstants.DEFAULT_CACHE_EXPIRATION_DAYS
        )

        return aiQuestions
    }

    /**
     * Generate mock questions for development when cache is empty
     *
     * **DEVELOPMENT ONLY**: This fallback ensures interview can be tested
     * even when question cache is not populated.
     */
    private fun generateMockQuestions(count: Int): List<InterviewQuestion> {
        return try {
            // Read JSON from assets
            val jsonString = context.assets.open("fallback_interview_questions.json")
                .bufferedReader()
                .use { it.readText() }

            // Parse JSON
            val type = object : TypeToken<FallbackQuestionsFile>() {}.type
            val questionsFile: FallbackQuestionsFile = gson.fromJson(jsonString, type)

            // Convert to InterviewQuestion objects
            val questions = questionsFile.questions.map { dto ->
                InterviewQuestion(
                    id = UUID.randomUUID().toString(),
                    questionText = dto.questionText,
                    expectedOLQs = dto.expectedOLQs.mapNotNull { olqName ->
                        try {
                            OLQ.valueOf(olqName)
                        } catch (e: IllegalArgumentException) {
                            Log.e(TAG, "Invalid OLQ name in fallback questions: $olqName")
                            null
                        }
                    },
                    context = dto.context,
                    source = QuestionSource.GENERIC_POOL
                )
            }

            Log.i(TAG, "Loaded ${questions.size} fallback questions from JSON asset")
            questions.take(count)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to load fallback questions from JSON, using emergency fallback")

            // Emergency fallback: minimal hardcoded questions if JSON fails to load
            listOf(
                InterviewQuestion(
                    id = UUID.randomUUID().toString(),
                    questionText = "Tell me about yourself and your background.",
                    expectedOLQs = listOf(OLQ.SELF_CONFIDENCE, OLQ.POWER_OF_EXPRESSION),
                    context = "Emergency fallback question",
                    source = QuestionSource.GENERIC_POOL
                ),
                InterviewQuestion(
                    id = UUID.randomUUID().toString(),
                    questionText = "Why do you want to join the armed forces?",
                    expectedOLQs = listOf(OLQ.DETERMINATION, OLQ.SENSE_OF_RESPONSIBILITY),
                    context = "Emergency fallback question",
                    source = QuestionSource.GENERIC_POOL
                )
            ).take(count)
        }
    }

    /**
     * DTOs for parsing fallback questions JSON
     */
    private data class FallbackQuestionsFile(
        val version: String,
        val description: String,
        val lastUpdated: String,
        val questions: List<FallbackQuestionDTO>
    )

    private data class FallbackQuestionDTO(
        val questionText: String,
        val expectedOLQs: List<String>,
        val context: String
    )
}


