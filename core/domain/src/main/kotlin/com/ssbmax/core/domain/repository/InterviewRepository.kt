package com.ssbmax.core.domain.repository

import com.ssbmax.core.domain.model.interview.InterviewMode
import com.ssbmax.core.domain.model.interview.InterviewQuestion
import com.ssbmax.core.domain.model.interview.InterviewResponse
import com.ssbmax.core.domain.model.interview.InterviewResult
import com.ssbmax.core.domain.model.interview.InterviewSession
import com.ssbmax.core.domain.model.interview.PrerequisiteCheckResult
import kotlinx.coroutines.flow.Flow

/**
 * Repository interface for interview operations
 */
interface InterviewRepository {

    // Prerequisites validation

    /**
     * Check if user meets all prerequisites to start an interview
     *
     * @param userId User to check
     * @return Prerequisite validation result
     */
    suspend fun checkPrerequisites(userId: String): Result<PrerequisiteCheckResult>

    /**
     * Check interview limits for user's subscription tier
     *
     * @param userId User to check
     * @param mode Interview mode (text or voice)
     * @return True if user has remaining interviews, false otherwise
     */
    suspend fun checkInterviewLimits(userId: String, mode: InterviewMode): Result<Boolean>

    // Session management

    /**
     * Create a new interview session
     *
     * @param userId User starting the interview
     * @param mode Interview mode
     * @param piqSnapshotId PIQ data to use for question generation
     * @param consentGiven Consent for transcript storage
     * @return Created interview session
     */
    suspend fun createSession(
        userId: String,
        mode: InterviewMode,
        piqSnapshotId: String,
        consentGiven: Boolean
    ): Result<InterviewSession>

    /**
     * Get active interview session for user
     *
     * @param userId User ID
     * @return Active session if exists, null otherwise
     */
    suspend fun getActiveSession(userId: String): Result<InterviewSession?>

    /**
     * Get interview session by ID
     *
     * @param sessionId Session ID
     * @return Interview session
     */
    suspend fun getSession(sessionId: String): Result<InterviewSession>

    /**
     * Update interview session
     *
     * @param session Updated session data
     */
    suspend fun updateSession(session: InterviewSession): Result<Unit>

    /**
     * Abandon interview session
     *
     * @param sessionId Session to abandon
     */
    suspend fun abandonSession(sessionId: String): Result<Unit>

    // Question management

    /**
     * Generate interview questions for session
     *
     * Uses hybrid caching strategy:
     * - 70% PIQ-based questions (from cache, pre-generated by background worker)
     * - 25% generic pool questions (from permanent Firestore collection)
     * - 5% reserved for future adaptive questions (based on interview progress)
     *
     * @param sessionId Interview session
     * @param piqSnapshotId PIQ data for personalization
     * @param count Number of questions to generate
     * @return List of interview questions
     */
    suspend fun generateQuestions(
        sessionId: String,
        piqSnapshotId: String,
        count: Int
    ): Result<List<InterviewQuestion>>

    /**
     * Get question by ID
     *
     * @param questionId Question ID
     * @return Interview question
     */
    suspend fun getQuestion(questionId: String): Result<InterviewQuestion>

    /**
     * Cache PIQ-based questions for future use
     *
     * @param piqSnapshotId PIQ data
     * @param questions Questions to cache
     */
    suspend fun cacheQuestions(
        piqSnapshotId: String,
        questions: List<InterviewQuestion>
    ): Result<Unit>

    /**
     * Get cached questions for PIQ snapshot
     *
     * @param piqSnapshotId PIQ snapshot ID
     * @param limit Maximum number of questions to retrieve
     * @return Cached questions
     */
    suspend fun getCachedQuestions(
        piqSnapshotId: String,
        limit: Int
    ): Result<List<InterviewQuestion>>

    // Response management

    /**
     * Submit candidate response to a question
     *
     * @param response Interview response with OLQ scores
     * @return Saved response
     */
    suspend fun submitResponse(response: InterviewResponse): Result<InterviewResponse>

    /**
     * Get all responses for a session
     *
     * @param sessionId Interview session ID
     * @return List of responses
     */
    suspend fun getResponses(sessionId: String): Result<List<InterviewResponse>>

    /**
     * Get specific response by ID
     *
     * @param responseId Response ID
     * @return Interview response
     */
    suspend fun getResponse(responseId: String): Result<InterviewResponse>

    /**
     * Update response with OLQ scores (used by background analysis worker)
     *
     * @param response Updated response with OLQ scores
     * @return Updated response
     */
    suspend fun updateResponse(response: InterviewResponse): Result<InterviewResponse>

    // Result management

    /**
     * Complete interview and generate final result
     *
     * Aggregates all responses, calculates OLQ scores,
     * identifies strengths/weaknesses, and generates feedback
     *
     * @param sessionId Completed interview session
     * @return Final interview result
     */
    suspend fun completeInterview(sessionId: String): Result<InterviewResult>

    /**
     * Get interview result by session ID
     *
     * @param sessionId Interview session ID
     * @return Interview result
     */
    suspend fun getResult(sessionId: String): Result<InterviewResult>

    /**
     * Get interview result by result ID
     *
     * @param resultId Result ID
     * @return Interview result
     */
    suspend fun getResultById(resultId: String): Result<InterviewResult>

    /**
     * Get all interview results for user
     *
     * @param userId User ID
     * @return Flow of interview results sorted by completion date (newest first)
     */
    fun getUserResults(userId: String): Flow<List<InterviewResult>>

    // Analytics

    /**
     * Get user's interview statistics
     *
     * @param userId User ID
     * @return Interview count by mode
     */
    suspend fun getInterviewStats(userId: String): Result<Map<InterviewMode, Int>>

    /**
     * Get remaining interview count for user
     *
     * @param userId User ID
     * @param mode Interview mode
     * @return Remaining interviews available
     */
    suspend fun getRemainingInterviews(userId: String, mode: InterviewMode): Result<Int>
}
